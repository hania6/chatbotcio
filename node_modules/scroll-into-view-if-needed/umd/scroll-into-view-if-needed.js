(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.scrollIntoView = factory());
}(this, (function () { 'use strict';

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  var isElement = function isElement(el) {
    return el != null && typeof el == 'object' && el.nodeType === 1;
  };

  var hasScrollableSpace = function hasScrollableSpace(el, axis) {
    if (axis === 'Y') {
      return el.clientHeight < el.scrollHeight;
    }

    if (axis === 'X') {
      return el.clientWidth < el.scrollWidth;
    }

    return false;
  };

  var canOverflow = function canOverflow(el, axis) {
    var overflowValue = window.getComputedStyle(el, null)['overflow' + axis];
    return overflowValue !== 'visible' && overflowValue !== 'clip';
  };

  var isScrollable = function isScrollable(el) {
    return hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y') || hasScrollableSpace(el, 'X') && canOverflow(el, 'X');
  };

  var alignNearest = function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, elementEdgeStart, elementEdgeEnd, elementSize) {
    if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {
      return 0;
    }

    if (elementEdgeStart < scrollingEdgeStart && elementSize < scrollingSize || elementEdgeEnd > scrollingEdgeEnd && elementSize > scrollingSize) {
      return elementEdgeStart - scrollingEdgeStart;
    }

    if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {
      return elementEdgeEnd - scrollingEdgeEnd;
    }

    return 0;
  };

  var compute = (function (target, options) {
    if (options === void 0) {
      options = {};
    }

    var _scrollMode$block$inl = _extends({
      scrollMode: 'always',
      block: 'center',
      inline: 'nearest'
    }, options),
        scrollMode = _scrollMode$block$inl.scrollMode,
        block = _scrollMode$block$inl.block,
        inline = _scrollMode$block$inl.inline,
        boundary = _scrollMode$block$inl.boundary;

    var checkBoundary = typeof boundary == 'function' ? boundary : function (parent) {
      return parent !== boundary;
    };

    if (!isElement(target)) {
      throw new Error('Element is required in scrollIntoView');
    }

    var targetRect = target.getBoundingClientRect();
    var viewport = document.documentElement;
    var frames = [];
    var parent;

    while (isElement(parent = target.parentNode) && checkBoundary(target)) {
      if (isScrollable(parent) || parent === viewport) {
        frames.push(parent);
      }

      target = parent;
    }

    var viewportWidth = window.visualViewport ? window.visualViewport.width : viewport.clientWidth;
    var viewportHeight = window.visualViewport ? window.visualViewport.height : viewport.clientHeight;
    var viewportX = window.scrollX || window.pageXOffset;
    var viewportY = window.scrollY || window.pageYOffset;

    if (scrollMode === 'if-needed') {
      var isVisible = frames.every(function (frame) {
        var frameRect = frame.getBoundingClientRect();

        if (targetRect.top < frameRect.top) {
          return false;
        }

        if (targetRect.bottom > frameRect.bottom) {
          return false;
        }

        if (frame === viewport) {
          if (targetRect.bottom > viewportHeight) {
            return false;
          }

          if (targetRect.left > viewportWidth) {
            return false;
          }
        }

        return true;
      });

      if (isVisible) {
        return [];
      }
    }

    var targetBlock;
    var targetInline;
    var computations = frames.map(function (frame) {
      var frameRect = frame.getBoundingClientRect();
      var blockScroll = 0;
      var inlineScroll = 0;

      if (block === 'start') {
        if (!targetBlock) {
          targetBlock = targetRect.top;
        }

        if (viewport === frame) {
          blockScroll = viewportY + targetBlock;
        } else {
          var offset = Math.min(targetBlock - frameRect.top, frame.scrollHeight - frame.clientHeight - frame.scrollTop);
          blockScroll = frame.scrollTop + offset;
          targetBlock -= blockScroll - frame.scrollTop;
        }
      }

      if (block === 'center') {
        if (!targetBlock) {
          targetBlock = targetRect.top + targetRect.height / 2;
        }

        if (viewport === frame) {
          blockScroll = viewportY + targetBlock - frame.clientHeight / 2;
        } else {
          var _offset = 0 - Math.min(frameRect.top + frameRect.height / 2 - targetBlock, frame.scrollTop);

          blockScroll = frame.scrollTop + _offset;
          targetBlock += frame.scrollTop - blockScroll;
        }
      }

      if (block === 'end') {
        if (!targetBlock) {
          targetBlock = targetRect.bottom;
        }

        if (viewport === frame) {
          blockScroll = viewportY + targetBlock - frame.clientHeight;
        } else {
          var _offset2 = 0 - Math.min(frameRect.bottom - targetBlock, frame.scrollTop);

          blockScroll = frame.scrollTop + _offset2;
          targetBlock += frame.scrollTop - blockScroll;
        }
      }

      if (block === 'nearest') {
        if (!targetBlock) {
          targetBlock = targetRect.top;
        }

        if (viewport === frame) {
          var _offset3 = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, viewportY + targetBlock, viewportY + targetBlock + targetRect.height, targetRect.height);

          blockScroll = viewportY + _offset3;
        } else {
          var _offset4 = alignNearest(frameRect.top, frameRect.bottom, frameRect.height, targetBlock, targetBlock + targetRect.height, targetRect.height);

          blockScroll = frame.scrollTop + _offset4;
          targetBlock -= _offset4;
        }
      }

      if (inline === 'start') {
        if (!targetInline) {
          targetInline = targetRect.left;
        }

        if (viewport === frame) {
          inlineScroll = viewportX + targetInline;
        } else {
          var _offset5 = Math.min(targetInline - frameRect.left, frame.scrollHeight - frame.clientLeft - frame.scrollLeft);

          inlineScroll = frame.scrollLeft + _offset5;
          targetInline -= inlineScroll - frame.scrollLeft;
        }
      }

      if (inline === 'center') {
        if (!targetInline) {
          targetInline = targetRect.left + targetRect.width / 2;
        }

        if (viewport === frame) {
          inlineScroll = viewportX + targetInline - frame.clientWidth / 2;
        } else {
          var _offset6 = 0 - Math.min(frameRect.left + frameRect.width / 2 - targetInline, frame.scrollLeft);

          inlineScroll = frame.scrollLeft + _offset6;
          targetInline += frame.scrollLeft - inlineScroll;
        }
      }

      if (inline === 'end') {
        if (!targetInline) {
          targetInline = targetRect.right;
        }

        if (viewport === frame) {
          inlineScroll = viewportX + targetInline - frame.clientWidth;
        } else {
          var _offset7 = 0 - Math.min(frameRect.right - targetInline, frame.scrollLeft);

          inlineScroll = frame.scrollLeft + _offset7;
          targetInline += frame.scrollLeft - inlineScroll;
        }
      }

      if (inline === 'nearest') {
        if (!targetInline) {
          targetInline = targetRect.left;
        }

        if (viewport === frame) {
          var _offset8 = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, viewportX + targetInline, viewportX + targetInline + targetRect.width, targetRect.width);

          inlineScroll = viewportX + _offset8;
        } else {
          var _offset9 = alignNearest(frameRect.left, frameRect.right, frameRect.width, targetInline, targetInline + targetRect.width, targetRect.width);

          inlineScroll = frame.scrollLeft + _offset9;
          targetInline -= _offset9;
        }
      }

      return {
        el: frame,
        top: blockScroll,
        left: inlineScroll
      };
    });
    return computations;
  });

  var supportsScrollBehavior;
  var index = (function (target, maybeOptions) {
    if (maybeOptions === void 0) {
      maybeOptions = true;
    }

    var options = {};

    if (supportsScrollBehavior === undefined) {
      supportsScrollBehavior = 'scrollBehavior' in document.documentElement.style;
    }

    if (maybeOptions === true || maybeOptions === null) {
      options = {
        block: 'start',
        inline: 'nearest'
      };
    } else if (maybeOptions === false) {
      options = {
        block: 'end',
        inline: 'nearest'
      };
    } else if (maybeOptions === Object(maybeOptions)) {
      options = Object.keys(maybeOptions).length === 0 ? {
        block: 'start',
        inline: 'nearest'
      } : _extends({
        block: 'center',
        inline: 'nearest'
      }, maybeOptions);
    }

    var _options = options,
        _options$behavior = _options.behavior,
        behavior = _options$behavior === void 0 ? 'auto' : _options$behavior,
        computeOptions = _objectWithoutProperties(_options, ["behavior"]);

    var instructions = compute(target, computeOptions);

    if (typeof behavior == 'function') {
      return behavior(instructions);
    }

    instructions.forEach(function (_ref) {
      var el = _ref.el,
          top = _ref.top,
          left = _ref.left;

      if (el.scroll && supportsScrollBehavior) {
        el.scroll({
          top: top,
          left: left,
          behavior: behavior
        });
      } else {
        if (el === document.documentElement) {
          window.scrollTo(left, top);
        } else {
          el.scrollTop = top;
          el.scrollLeft = left;
        }
      }
    });
  });

  return index;

})));
