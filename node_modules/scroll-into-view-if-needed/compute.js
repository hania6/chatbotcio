"use strict";

exports.__esModule = true;
exports.default = void 0;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var isElement = function isElement(el) {
  return el != null && typeof el == 'object' && el.nodeType === 1;
};

var hasScrollableSpace = function hasScrollableSpace(el, axis) {
  if (axis === 'Y') {
    return el.clientHeight < el.scrollHeight;
  }

  if (axis === 'X') {
    return el.clientWidth < el.scrollWidth;
  }

  return false;
};

var canOverflow = function canOverflow(el, axis) {
  var overflowValue = window.getComputedStyle(el, null)['overflow' + axis];
  return overflowValue !== 'visible' && overflowValue !== 'clip';
};

var isScrollable = function isScrollable(el) {
  return hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y') || hasScrollableSpace(el, 'X') && canOverflow(el, 'X');
};

var alignNearest = function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, elementEdgeStart, elementEdgeEnd, elementSize) {
  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {
    return 0;
  }

  if (elementEdgeStart < scrollingEdgeStart && elementSize < scrollingSize || elementEdgeEnd > scrollingEdgeEnd && elementSize > scrollingSize) {
    return elementEdgeStart - scrollingEdgeStart;
  }

  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {
    return elementEdgeEnd - scrollingEdgeEnd;
  }

  return 0;
};

var _default = function _default(target, options) {
  if (options === void 0) {
    options = {};
  }

  var _scrollMode$block$inl = _extends({
    scrollMode: 'always',
    block: 'center',
    inline: 'nearest'
  }, options),
      scrollMode = _scrollMode$block$inl.scrollMode,
      block = _scrollMode$block$inl.block,
      inline = _scrollMode$block$inl.inline,
      boundary = _scrollMode$block$inl.boundary;

  var checkBoundary = typeof boundary == 'function' ? boundary : function (parent) {
    return parent !== boundary;
  };

  if (!isElement(target)) {
    throw new Error('Element is required in scrollIntoView');
  }

  var targetRect = target.getBoundingClientRect();
  var viewport = document.documentElement;
  var frames = [];
  var parent;

  while (isElement(parent = target.parentNode) && checkBoundary(target)) {
    if (isScrollable(parent) || parent === viewport) {
      frames.push(parent);
    }

    target = parent;
  }

  var viewportWidth = window.visualViewport ? window.visualViewport.width : viewport.clientWidth;
  var viewportHeight = window.visualViewport ? window.visualViewport.height : viewport.clientHeight;
  var viewportX = window.scrollX || window.pageXOffset;
  var viewportY = window.scrollY || window.pageYOffset;

  if (scrollMode === 'if-needed') {
    var isVisible = frames.every(function (frame) {
      var frameRect = frame.getBoundingClientRect();

      if (targetRect.top < frameRect.top) {
        return false;
      }

      if (targetRect.bottom > frameRect.bottom) {
        return false;
      }

      if (frame === viewport) {
        if (targetRect.bottom > viewportHeight) {
          return false;
        }

        if (targetRect.left > viewportWidth) {
          return false;
        }
      }

      return true;
    });

    if (isVisible) {
      return [];
    }
  }

  var targetBlock;
  var targetInline;
  var computations = frames.map(function (frame) {
    var frameRect = frame.getBoundingClientRect();
    var blockScroll = 0;
    var inlineScroll = 0;

    if (block === 'start') {
      if (!targetBlock) {
        targetBlock = targetRect.top;
      }

      if (viewport === frame) {
        blockScroll = viewportY + targetBlock;
      } else {
        var offset = Math.min(targetBlock - frameRect.top, frame.scrollHeight - frame.clientHeight - frame.scrollTop);
        blockScroll = frame.scrollTop + offset;
        targetBlock -= blockScroll - frame.scrollTop;
      }
    }

    if (block === 'center') {
      if (!targetBlock) {
        targetBlock = targetRect.top + targetRect.height / 2;
      }

      if (viewport === frame) {
        blockScroll = viewportY + targetBlock - frame.clientHeight / 2;
      } else {
        var _offset = 0 - Math.min(frameRect.top + frameRect.height / 2 - targetBlock, frame.scrollTop);

        blockScroll = frame.scrollTop + _offset;
        targetBlock += frame.scrollTop - blockScroll;
      }
    }

    if (block === 'end') {
      if (!targetBlock) {
        targetBlock = targetRect.bottom;
      }

      if (viewport === frame) {
        blockScroll = viewportY + targetBlock - frame.clientHeight;
      } else {
        var _offset2 = 0 - Math.min(frameRect.bottom - targetBlock, frame.scrollTop);

        blockScroll = frame.scrollTop + _offset2;
        targetBlock += frame.scrollTop - blockScroll;
      }
    }

    if (block === 'nearest') {
      if (!targetBlock) {
        targetBlock = targetRect.top;
      }

      if (viewport === frame) {
        var _offset3 = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, viewportY + targetBlock, viewportY + targetBlock + targetRect.height, targetRect.height);

        blockScroll = viewportY + _offset3;
      } else {
        var _offset4 = alignNearest(frameRect.top, frameRect.bottom, frameRect.height, targetBlock, targetBlock + targetRect.height, targetRect.height);

        blockScroll = frame.scrollTop + _offset4;
        targetBlock -= _offset4;
      }
    }

    if (inline === 'start') {
      if (!targetInline) {
        targetInline = targetRect.left;
      }

      if (viewport === frame) {
        inlineScroll = viewportX + targetInline;
      } else {
        var _offset5 = Math.min(targetInline - frameRect.left, frame.scrollHeight - frame.clientLeft - frame.scrollLeft);

        inlineScroll = frame.scrollLeft + _offset5;
        targetInline -= inlineScroll - frame.scrollLeft;
      }
    }

    if (inline === 'center') {
      if (!targetInline) {
        targetInline = targetRect.left + targetRect.width / 2;
      }

      if (viewport === frame) {
        inlineScroll = viewportX + targetInline - frame.clientWidth / 2;
      } else {
        var _offset6 = 0 - Math.min(frameRect.left + frameRect.width / 2 - targetInline, frame.scrollLeft);

        inlineScroll = frame.scrollLeft + _offset6;
        targetInline += frame.scrollLeft - inlineScroll;
      }
    }

    if (inline === 'end') {
      if (!targetInline) {
        targetInline = targetRect.right;
      }

      if (viewport === frame) {
        inlineScroll = viewportX + targetInline - frame.clientWidth;
      } else {
        var _offset7 = 0 - Math.min(frameRect.right - targetInline, frame.scrollLeft);

        inlineScroll = frame.scrollLeft + _offset7;
        targetInline += frame.scrollLeft - inlineScroll;
      }
    }

    if (inline === 'nearest') {
      if (!targetInline) {
        targetInline = targetRect.left;
      }

      if (viewport === frame) {
        var _offset8 = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, viewportX + targetInline, viewportX + targetInline + targetRect.width, targetRect.width);

        inlineScroll = viewportX + _offset8;
      } else {
        var _offset9 = alignNearest(frameRect.left, frameRect.right, frameRect.width, targetInline, targetInline + targetRect.width, targetRect.width);

        inlineScroll = frame.scrollLeft + _offset9;
        targetInline -= _offset9;
      }
    }

    return {
      el: frame,
      top: blockScroll,
      left: inlineScroll
    };
  });
  return computations;
};

exports.default = _default;
module.exports = exports["default"];